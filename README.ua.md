# Rust-Chain: Блокчейн на Proof-of-Stake

Цей проект є спрощеною реалізацією блокчейну на основі Proof-of-Stake (PoS) мовою Rust. Він створений з акцентом на принципах Чистої Архітектури та демонструє основні концепції розподіленого реєстру, включаючи обробку транзакцій, консенсус та взаємодію між вузлами.

## Можливості

- **Консенсус Proof-of-Stake (PoS):** Простий механізм консенсусу PoS за принципом "round-robin" для вибору пропозиціонерів блоків.
- **Чиста Архітектура:** Чітке розділення відповідальності між доменною логікою, сценаріями використання додатку та інфраструктурою.
- **RESTful API:** API на основі Axum для взаємодії з блокчейном, що включає ендпоінти для створення транзакцій, перегляду блоків та перевірки балансів.
- **Взаємодія між вузлами (P2P):** Базова функціональність P2P для виявлення вузлів, синхронізації ланцюга та трансляції блоків і голосів.
- **Зберігання в пам'яті:** Використання структур даних в оперативній пам'яті для зберігання блокчейну, стану користувачів та мемпулу.
- **Підпис блоків на основі HMAC:** Блоки підписуються та перевіряються за допомогою HMAC-SHA256 для забезпечення цілісності.

## Архітектура

Проект дотримується принципів Чистої Архітектури, що забезпечує модульну, тестовану та підтримувану кодову базу. Код організовано в чотири основні шари:

- **Домен (`src/domain`):** Ядро програми, що містить бізнес-логіку та сутності, такі як `Block`, `Transaction` та `Node`. Він також визначає інтерфейси репозиторіїв (`BlockchainRepository`, `MempoolRepository`, `UserStateRepository`), які реалізуються інфраструктурним шаром.
- **Додаток (`src/blockchain/use_cases`):** Цей шар організовує потік даних та виконує бізнес-логіку, визначену в доменному шарі. Він містить сценарії використання, такі як `create_new_block`, `pos_consensus_loop` та `sync_chain_task`.
- **Інфраструктура (`src/infrastructure`):** Цей шар містить конкретні реалізації інтерфейсів репозиторіїв, визначених у доменному шарі. У цьому проекті ми використовуємо репозиторії в пам'яті.
- **API (`src/api`):** Зовнішній шар, який надає функціональність програми зовнішньому світу через RESTful API. Він обробляє HTTP-запити та відповіді та залежить від шару додатку для виконання запитаних дій.

## Основні Концепції

- **Блок:** Фундаментальний будівельний елемент ланцюга. Кожен блок містить заголовок, список транзакцій, власний хеш та хеш попереднього блоку.
- **Транзакція:** Переказ вартості від відправника до отримувача.
- **Стан користувача:** Сховище "ключ-значення", яке відображає UUID користувачів на баланси їхніх рахунків.
- **Мемпул:** Тимчасове сховище для транзакцій, які були надіслані, але ще не включені до блоку.
- **Вузол:** Учасник мережі, який підтримує копію блокчейну та спілкується з іншими вузлами.
- **Голос:** Повідомлення, що транслюється валідатором для сигналізації про схвалення запропонованого блоку.

## Консенсус Proof-of-Stake (PoS)

Механізм консенсусу є спрощеною реалізацією Proof-of-Stake за принципом "round-robin":

1.  **Прогресія на основі слотів:** Час поділено на слоти (наприклад, 5 секунд).
2.  **Вибір лідера:** У кожному слоті лідер обирається з попередньо визначеного списку валідаторів за принципом "round-robin".
3.  **Пропозиція блоку:** Лідер поточного слоту відповідає за створення нового блоку з транзакцій у мемпулі та його трансляцію своїм пірам.
4.  **Перевірка та голосування за блок:** Коли валідатор отримує новий блок, він перевіряє цілісність блоку, підпис та транзакції. Якщо блок є дійсним, валідатор транслює голос "ACK" за цей блок.
5.  **Кворум та фіналізація:** Блок вважається фіналізованим, як тільки він отримує кворум голосів (більше половини валідаторів). Лідер, який запропонував блок, відповідає за його додавання до свого ланцюга.
6.  **Синхронізація ланцюга:** Якщо вузол виявляє, що його ланцюг коротший за ланцюг піра, він ініціює процес синхронізації для завантаження довшого ланцюга.

## API Ендпоінти

| Метод | Шлях                | Опис                                      |
| ------ | --------------------- | ----------------------------------------- |
| GET    | `/blocks`             | Отримати всі блоки в ланцюзі.             |
| GET    | `/transactions`       | Отримати всі транзакції в мемпулі.        |
| POST   | `/transactions`       | Створити нову транзакцію.                 |
| POST   | `/user`               | Створити нового користувача з початковим балансом.|
| GET    | `/balances`           | Отримати баланси всіх користувачів.       |
| GET    | `/balance/:address`   | Отримати баланс конкретного користувача.  |
| POST   | `/block`              | Отримати новий блок від піра.             |
| POST   | `/vote`               | Отримати голос від піра.                  |

## Конфігурація

Додаток конфігурується за допомогою файлу `.env` у корені проекту.

```
SHARED_KEY="your-secret-key"
GENESIS_SENDER_ID="00000000-0000-0000-0000-000000000000"
FAUCET_WALLET_ID="11111111-1111-1111-1111-111111111111"
```

- **`SHARED_KEY`:** Секретний ключ, що використовується для підпису та перевірки блоків за допомогою HMAC-SHA256.
- **`GENESIS_SENDER_ID`:** UUID "системного" користувача, який фінансує "кран" у генезис-блоці.
- **`FAUCET_WALLET_ID`:** UUID гаманця "крана", який використовується для фінансування нових користувачів.

## Як Запустити

### Один Вузол

1.  **Встановіть Rust:** Якщо у вас не встановлено Rust, ви можете встановити його з [rust-lang.org](https://www.rust-lang.org/).
2.  **Створіть файл `.env`:** Створіть файл `.env` у корені проекту та додайте змінні конфігурації, як описано вище.
3.  **Запустіть вузол:**

    ```sh
    cargo run -- --id v1 --port 3001 --peers 3002,3003
    ```

### Мережа з Декількох Вузлів

Щоб запустити мережу з декількох вузлів, ви можете відкрити кілька вікон терміналу та запустити кожен вузол з різними ID, портами та списками пірів.

**Вузол 1:**

```sh
cargo run -- --id v1 --port 3001 --peers 3002,3003
```

**Вузол 2:**

```sh
cargo run -- --id v2 --port 3002 --peers 3001,3003
```

**Вузол 3:**

```sh
cargo run -- --id v3 --port 3003 --peers 3001,3002
```

## Структура Проекту

```
/
├── src/
│   ├── api/                # Веб-сервер Axum, обробники та DTO
│   ├── blockchain/         # Сценарії використання додатку
│   ├── domain/             # Основна бізнес-логіка та сутності
│   └── infrastructure/     # Конкретні реалізації репозиторіїв
├── .env                    # Файл конфігурації
├── Cargo.toml              # Залежності проекту
└── README.md               # Цей файл
```